import streamlit as st
import pandas as pd
import re
from viz import utils


def render_tab():
    st.title("sncRNAs Counts Viewer")
    
    st.warning(
        "The **sncRNA Counts Viewer** tab is designed specifically for output files generated by the PerSeqPIPE workflow. "
        "It relies on the exact column structure and formatting of files with the suffix `.short_rna_counts.tsv`. "
        "Using other files may result in errors or unexpected behavior.",
        icon="⚠️"
    )

    # File uploader
    uploaded_file = st.file_uploader("Upload a TSV file (**.short_rna_counts.tsv**)", type=["tsv"], help = "TSV tab-separated file with columns: sequence, expression, pirna, trna, snorna, srna, mrna, lncrna, genome_alignments, MINT_plate. If using PerSeqPIPE locate files with `.short_rna_counts.tsv` suffix in `quantification/` output folder and use these.")
        
    if uploaded_file is not None:

        # Read TSV file into a DataFrame
        df = pd.read_csv(uploaded_file, sep='\t')

        # Sort by 'expression' in descending order
        if 'expression' in df.columns:
            df = df.sort_values(by='expression', ascending=False)

        # Ensure the 'sequence' column is treated as a string
        if 'sequence' in df.columns:
            df['sequence'] = df['sequence'].astype(str)

        # Get min and max sequence lengths for slider limits
        min_seq_len = df['sequence'].str.len().min() if 'sequence' in df.columns else 0
        max_seq_len = df['sequence'].str.len().max() if 'sequence' in df.columns else 100

        # Get min/max expression values for slider
        min_expr = df['expression'].min() if 'expression' in df.columns else 0
        max_expr = df['expression'].max() if 'expression' in df.columns else 0

        # Get min/max genomic_alignments values for slider
        min_alignments = df['genome_alignments'].min() if 'genome_alignments' in df.columns else 0
        max_alignments = df['genome_alignments'].max() if 'genome_alignments' in df.columns else 100

        selectable_columns = ['snorna','pirna','srna','trna','mrna','lncrna','exclusive']

        selected_columns = st.multiselect("Select categories to filter sequences:", selectable_columns, default=[])

        col1, col2 = st.columns(2)
        with col1:
            # Length filter: Slider for selecting a range
            seq_length_range = st.slider(
                "Select sequence length range:",
                min_value=min_seq_len,
                max_value=max_seq_len,
                value=(min_seq_len, max_seq_len))
                
            # Expression range slider
            expr_range = st.slider("Select expression value range:", min_value=min_expr, max_value=max_expr, value=(min_expr, max_expr))
            
        with col2:
            # Genomic alignments slider (placed below sequence length slider)
            genomic_align_range = st.slider(
                "Genomic alignments range:", 
                min_value=min_alignments, 
                max_value=max_alignments, 
                value=(min_alignments, max_alignments)
            )

        col1, col2 = st.columns(2)
        with col1:
            # Substring filter input
            substring_filter = st.text_input("Filter by sequence:", "", help = "Filter table by specific sequence string, either substring or a full string.")

        with col2:
            # Global gene name filter (searches all columns)
            gene_filter = st.text_input("Filter by feature name:", "", help = "Filter table by assigned feature name, example `URS00000CFF4A_9606`")

        # Check if 'exclusive' is selected
        is_exclusive = 'exclusive' in selected_columns
        selected_columns = [col for col in selected_columns if col != 'exclusive']  # Remove 'exclusive' from list

        if selected_columns:
            if is_exclusive:
                # Keep rows where ONLY selected columns have values (other columns should be NaN)
                filtered_df = df[df[selected_columns].notna().any(axis=1) & df.drop(columns=selected_columns).isna().all(axis=1)]
            else:
                # Keep rows where ALL selected columns have values (normal filtering)
                filtered_df = df[df[selected_columns].notna().all(axis=1)]
        else:
            filtered_df = df  # Show full data if nothing selected

        # Apply length filtering if user sets a value > 0
        filtered_df = filtered_df[filtered_df['sequence'].str.len().between(seq_length_range[0], seq_length_range[1])]

        # Apply expression filtering
        filtered_df = filtered_df[filtered_df['expression'].between(expr_range[0], expr_range[1])]

        # Apply genomic alignments filtering
        filtered_df = filtered_df[filtered_df['genome_alignments'].between(genomic_align_range[0], genomic_align_range[1])]

        # Apply substring filtering
        if substring_filter:
            filtered_df = filtered_df[filtered_df['sequence'].str.contains(substring_filter, case=False, na=False)]

        # Apply gene name filtering (search in all columns)
        if gene_filter:
            filtered_df = filtered_df[filtered_df.astype(str).apply(lambda row: row.str.contains(gene_filter, case=False, na=False)).any(axis=1)]

        # Display the table
        #st.write("### Expr")
        st.dataframe(filtered_df)

        # Add a toggle for showing the subtable
        col1, col2 = st.columns(2)

        with col1:
            show_gene_table1 = st.toggle("Show Unique Loci-specific Gene Names", help="Show list of unique loci-specific gene names. If a gene can be found at multiple positions in genome (like many tRNA and piRNA), such gene name is given a suffix _loc{x}, such a gene name is called loci-specific gene name.")

            if show_gene_table1:
                unique_genes_df = utils.get_unique_gene_names(filtered_df)
                st.write("### Loci-specific Gene Names")
                st.dataframe(unique_genes_df)

        with col2:
            show_gene_table2 = st.toggle("Show Unique Gene Names", help = "Show list of unique gene names, wihout the loci suffix _loc{x}.")

            if show_gene_table2:
                unique_genes_df = utils.get_unique_gene_names(filtered_df)
                # Remove '_loc{X}' pattern and get unique values
                cleaned_genes = {re.sub(r'_loc\d+', '', gene) for gene in set(unique_genes_df["Unique Gene Names"])}
                cleaned_genes_df = pd.DataFrame(sorted(cleaned_genes), columns=["Cleaned Unique Gene Names"])
                st.write("### Unique Gene Names")
                st.dataframe(cleaned_genes_df)
